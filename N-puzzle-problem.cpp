#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <cmath>
#include <fstream>
#include <iomanip>

using namespace std;

struct Node {
    vector<vector<int>> state;
    int depth;
    double estimated_cost;
    Node *parent;
    string action;

    Node(const vector<vector<int>> &new_state, int depth, double path_cost, Node *parent, const string &action) : state(
            new_state), depth(depth), estimated_cost(path_cost), parent(parent), action(action) {};
};

void read_state(vector<vector<int>> &, ifstream &);

bool compare_states(const vector<vector<int>> &, const vector<vector<int>> &);

void print_state(const vector<vector<int>> &);

void print_result(Node *, Node *, double, int);

void get_position(const vector<vector<int>> &, int &, int &, int);

bool check_state(const vector<vector<int>> &, const vector<Node *> &, const vector<Node *> &);

double total_estimated_cost(const vector<vector<int>> &, const vector<vector<int>> &, double, double);

void add_to_queue(vector<Node *> &, Node *);

void generate_states(Node *, const vector<vector<int>> &, vector<Node *> &, vector<Node *> &, double);

Node *find_solution(vector<Node *> &, vector<Node *> &, const vector<vector<int>> &, double);

/*
 * Reads the input for the state
 * parameters:
 * state - vector<vector<int>> - vector in which the state would be stored
 * returns:
 * void
 */
void read_state(vector<vector<int>> &state, ifstream &ifs) {
    vector<int> single_line;
    int temp;
//    reads the input
    for (size_t i = 0; i < 3; i++) {
        for (size_t j = 0; j < 4; j++) {
            ifs >> temp;
            single_line.push_back(temp);
        }
        state.push_back(single_line);
        single_line.clear();
    }
}

/*
 * Compares the two states passed to it
 * to check if they are equal or not
 * parameters:
 * state_1 - vector<vector<int>> - First state that would be compared
 * state_2 - vector<vector<int>> - Second state that would be compared
 * returns:
 * bool - True if they are equal, false otherwise
 */
bool compare_states(const vector<vector<int>> &state_1, const vector<vector<int>> &state_2) {
//    goes through the vector comparing the positions of each tile
    for (size_t i = 0; i < state_1.size(); i++) {
        for (size_t j = 0; j < state_1[i].size(); j++) {
//            if position of the tile differs then return false
            if (state_1[i][j] != state_2[i][j]) {
                return false;
            }
        }
    }
//    return true if the states are the same
    return true;
}

/*
 * Prints out the state passed to it
 * parameters:
 * state - vector<vector<int>> - the state to be printed
 * returns:
 * void
 */
void print_state(const vector<vector<int>> &state) {
//    iterates through the state printing out each tile
    for (size_t i = 0; i < 3; i++) {
        for (size_t j = 0; j < 4; j++) {
            cout << state[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}

/*
 * Prints out the final result after finding the solution to obtain the goal state
 * parameters:
 * initial_node - Node* - initial node given to the program
 * goal_node - Node* - goal node reached by the system
 * W - double -
 * nodes - int - represents the total number of states generated by the program
 * returns:
 * void
 */
void print_result(Node *initial_node, Node *goal_node, double W, int nodes) {
//    vector to store the steps taken to reach the goal state from the initial state
    vector<Node *> sol;
    Node *temp = goal_node;
    while (temp->parent != nullptr) {
        sol.push_back(temp);
        temp = temp->parent;
    }

    sol.push_back(initial_node);
    reverse(sol.begin(), sol.end());

//    prints the initial and goal states
    print_state(initial_node->state);
    print_state(goal_node->state);

//    prints out W, total moves taken to reach the solution,
//    and total nodes generated
    cout << fixed << setprecision(1) << W << endl;
    cout << goal_node->depth << endl;
    cout << nodes << endl;

//    prints out the solution (how to get to the goal state from the initial state)
    for (size_t i = 1; i < sol.size(); i++) {
        cout << sol[i]->action << " ";
    }
    cout << endl;

//    prints out the total estimated cost for each of the nodes (from initial node to goal node)
    for (auto &i: sol) {
        cout << i->estimated_cost << " ";
    }
}

/*
 * Given a state, it finds the position of the tile passed to it
 * parameters:
 *      state - vector<vector<int>> - state for which the position should be found
 *      i - int - stores the x co-ordinate of the tile
 *      j - int - stores the y co-ordinate of the tile
 *      value - int - the tile whose position should be found
 * returns:
 *      void
 */
void get_position(const vector<vector<int>> &state, int &i, int &j, int value) {
//    iterates through the state to find the tile
    for (size_t k = 0; k < state.size(); k++) {
        for (size_t l = 0; l < state[i].size(); l++) {
            if (state[k][l] == value) {
                i = k;
                j = l;
                return;
            }
        }
    }
}

/*
 * Checks if the state generated by the program already exists
 * parameters:
 *      temp_state - vector<vector<int>> - new state which has been generated
 *      queue - vector<Node *> - priority queue containing all the nodes generated
 *      processed - vector<Node *> - vector containing the nodes which have been expanded
 * returns:
 *      bool - true if the state exists, false otherwise
 */
bool check_state(const vector<vector<int>> &temp_state, const vector<Node *> &queue, const vector<Node *> &processed) {
//    checks if any node in the queue has the same state
    for (auto i: queue) {
        if (compare_states(i->state, temp_state)) {
            return true;
        }
    }
//    checks if any of the nodes previously expanded had the same state
    for (auto i: processed) {
        if (compare_states(i->state, temp_state)) {
            return true;
        }
    }
    return false;
}

/*
 * Calculates the estimated total cost for the given state
 * parameters:
 *      state - vector<vector<int>> - the passed state
 *      goal_state - vector<vector<int>> - the goal state
 *      parent_cost - double - no. of steps taken to get to the parent node from the initial node
 *      W - double - weight of the heuristic function
 * returns:
 * double - total estimated cost
 */
double total_estimated_cost(const vector<vector<int>> &state, const vector<vector<int>> &goal_state, double parent_cost,
                            double W) {
    double heuristic = 0;
    int k, l;
    for (int i = 0; i < state.size(); i++) {
        for (int j = 0; j < state[i].size(); j++) {
//            finds the position of each tile in the goal state
            get_position(goal_state, k, l, state[i][j]);
//            computes the manhattan distance and adds it to the heuristic
            heuristic += abs(k - i);
            heuristic += abs(l - j);
        }
    }
//    multiplies the heuristic by the weight
    heuristic *= W;
    return parent_cost + 1 + heuristic;
}

/*
 * Inserts the generated node into the priority queue
 * parameters:
 *      queue - vector<Node *> - priority queue containing unexpanded nodes
 *      Node - Node* - node to be inserted in the queue
 * returns:
 *      void
 */
void add_to_queue(vector<Node *> &queue, Node *Node) {
    size_t index = queue.size();
//    finds the index where the node should be inserted
    for (size_t i = 0; i < queue.size(); i++) {
//        compares the total estimated costs and determines if the node
//        should be inserted
        if (Node->estimated_cost < queue[i]->estimated_cost) {
            index = i;
            break;
        }
    }

//    inserts the node at the last if it has the max total estimated cost
    if (queue.size() == index) {
        queue.push_back(Node);
        return;
    }
//    inserts the node at the appropriate position in the queue
    auto pos = queue.begin() + index;
    queue.insert(pos, Node);
}

/*
 * generates all possible states possible from the current state and adds them to the queue
 * parameters:
 *      node - Node* - the node to be expanded
 *      goal_state - vector<vector<int>> - the goal state we're looking for
 *      queue - vector<Node *> - The priority queue containing unexpanded nodes
 *      processed - vector<Node *> - vector containing the expanded nodes
 *      W - double - weight of the heuristic function
 */
void
generate_states(Node *node, const vector<vector<int>> &goal_state, vector<Node *> &queue, vector<Node *> &processed,
                double W) {
    int i, j, temp;
    double estimated_cost;
//    finds the position of the blank tile
    get_position(node->state, i, j, 0);

//    stores the current state in a new vector to not modify the original
    vector<vector<int>> temp_state = node->state;

//    depending on the position of the tile, additional states are generated
    if (i + 1 < node->state.size()) {
        temp_state[i + 1][j] = node->state[i][j];
        temp_state[i][j] = node->state[i + 1][j];

//        if the state generated hasn't already been generated then add it to the queue
        if (!check_state(temp_state, queue, processed)) {
            estimated_cost = total_estimated_cost(temp_state, goal_state, node->depth, W);
            add_to_queue(queue, new Node(temp_state, node->depth + 1, estimated_cost, node, "D"));
        }
    }
    temp_state = node->state;
    if (i - 1 > -1) {
        temp_state[i - 1][j] = node->state[i][j];
        temp_state[i][j] = node->state[i - 1][j];
        if (!check_state(temp_state, queue, processed)) {
            estimated_cost = total_estimated_cost(temp_state, goal_state, node->depth, W);
            add_to_queue(queue, new Node(temp_state, node->depth + 1, estimated_cost, node, "U"));
        }
    }
    temp_state = node->state;
    if (j + 1 < node->state[i].size()) {
        temp_state[i][j + 1] = node->state[i][j];
        temp_state[i][j] = node->state[i][j + 1];
        if (!check_state(temp_state, queue, processed)) {
            estimated_cost = total_estimated_cost(temp_state, goal_state, node->depth, W);
            add_to_queue(queue, new Node(temp_state, node->depth + 1, estimated_cost, node, "R"));
        }
    }
    temp_state = node->state;
    if (j - 1 > -1) {
        temp_state[i][j - 1] = node->state[i][j];
        temp_state[i][j] = node->state[i][j - 1];
        if (!check_state(temp_state, queue, processed)) {
            estimated_cost = total_estimated_cost(temp_state, goal_state, node->depth, W);
            add_to_queue(queue, new Node(temp_state, node->depth + 1, estimated_cost, node, "L"));
        }
    }
}

/*
 * finds the solution for the given case
 * parameters:
 *      goal_state - vector<vector<int>> - the goal state we're looking for
 *      queue - vector<Node *> - The priority queue containing unexpanded nodes
 *      processed - vector<Node *> - vector containing the expanded nodes
 *      W - double - weight of the heuristic function
 * returns:
 *      Node * - goal node
 */
Node *find_solution(vector<Node *> &queue, vector<Node *> &processed, const vector<vector<int>> &goal_state, double W) {
    Node *curr_node = nullptr;
//    runs until all unexpanded nodes have been expanded
    while (!queue.empty()) {
//        gets the front node and removes it from the queue
        curr_node = queue[0];
        queue.erase(queue.begin());
//        adds current node to processed
        processed.push_back(curr_node);
//        if the current node is the goal node then the solution is returned
        if (compare_states(curr_node->state, goal_state)) {
            return curr_node;
        }
//        all possible states are generated from the current state
        generate_states(curr_node, goal_state, queue, processed, W);
    }
//    if no solution is found nullptr is returned
    return nullptr;
}

int main() {
//    vectors to store the initial and goal state
    vector<vector<int>> initial_state;
    vector<vector<int>> goal_state;

//    priority queue to store the unexpanded nodes
    vector<Node *> queue;
//    vector to store the expanded nodes
    vector<Node *> processed;
//    vector to store the solution
    vector<string> sol;
    double W;
//    change file name here for different inputs
    ifstream ifs("Input1.txt");
    if (!ifs) {
        cerr << "File not found";
        exit(1);
    }

//    reads the file
    read_state(initial_state, ifs);
    read_state(goal_state, ifs);
    cin >> W;
    double estimated_cost = total_estimated_cost(initial_state, goal_state, 0, W);
    Node *initial_node = new Node(initial_state, 0, estimated_cost, nullptr, "");
    Node *goal_node = nullptr;

//    if initial state is the goal state, print the solution
    if (compare_states(initial_state, goal_state)) {
        print_result(initial_node, initial_node, W, 1);
    } else {
        queue.push_back(initial_node);
        goal_node = find_solution(queue, processed, goal_state, W);

//        prints our the solution if found
        if (goal_node != nullptr) {
            print_result(initial_node, goal_node, W, queue.size() + processed.size());
        } else {
            cout << "No result found for this problem" << endl;
        }
    }
    return 0;
}
